2024-05-09.md

```
N, M = gets.split.map(&:to_i)
open = []
comleted = false
N.times do |i|
    open << gets.to_i
    
    if open.uniq.size == M
        puts i + 1
        comleted = true
        break
    end
end

puts "unlucky" unless comleted
```
completedのような変数は「フラグ変数」と呼ばれるもので、プログラムの状態を記録するために使います。この場合は「すべてのカード種類が揃ったかどうか」という状態を記録しています。最初はfalse（揃っていない）で、条件を満たしたときにtrue（揃った）に変更します。
これはプログラムの流れを制御するのに非常に便利です。
unlessについて
unlessはRubyの条件分岐で、「〜でない場合」を表します。つまり：
rubyunless 条件
  # 条件が偽の場合に実行
end
これは以下のif文と同等です：
rubyif !条件
  # 条件が偽の場合に実行
end
unless completedは「completedがfalseの場合」、つまり「全種類揃わなかった場合」という意味になります。
timesメソッドと+1について
N.times do |i|のブロック内のiは0から始まります（0-indexed）。つまり：

最初のループではiは0
2回目のループではiは1
3回目のループではiは2
...

しかし、問題では「何枚目のカードで揃ったか」を求めていて、これは1から始まる数え方（1-indexed）です。カードの枚数は「1枚目、2枚目、3枚目...」と数えますよね。
そのため、「i+1」とすることで、0-indexedの値を1-indexedに変換しています：

i=0のとき、i+1=1（1枚目）
i=1のとき、i+1=2（2枚目）
i=2のとき、i+1=3（3枚目）
...

この変換は、プログラミングでは非常によく行われる操作です。特にプログラムの内部では0から始まるカウントを使い、ユーザーに表示するときは1から始まるカウントを使うことが多いです。
例えば、以下のように変更すれば、timesメソッドの挙動を変更することもできます：
ruby(1..N).each do |i|
  # ここでのiは1から始まる
end
または：
ruby1.upto(N) do |i|
  # ここでのiは1から始まる
end
これらを使えば「i+1」の変換が不要になりますが、Rubyでは伝統的にtimesメソッドが使われることが多いです。
まとめ
これらの概念は少し難しく感じるかもしれませんが、プログラミングの基本的なテクニックです。特に：

フラグ変数で状態を管理する
unlessを使って否定条件を簡潔に書く
インデックスの変換（0-indexedと1-indexed）